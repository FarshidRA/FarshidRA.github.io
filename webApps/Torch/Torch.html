<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Interactive Object Detection 3:4</title>
<style>
  body {
    margin:0;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
    background:#000;
  }
  #container {
    position:relative;
    width:360px;
    height:480px; /* 3:4 aspect ratio */
    background:#000;
    overflow:hidden;
    display:flex;
    justify-content:center;
    align-items:center;
  }
  video#cam {
    display:block;
    max-width:100%;
    max-height:100%;
  }
  canvas#overlay {
    position:absolute;
    top:0;
    left:0;
    width:100%;
    height:100%;
    touch-action: none;
  }
</style>
</head>
<body>
<div id="container">
  <video id="cam" autoplay playsinline></video>
  <canvas id="overlay"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.7.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
<script>
(async ()=>{
const video = document.getElementById('cam');
const canvas = document.getElementById('overlay');
const ctx = canvas.getContext('2d');
let model;
let boxes = []; // store detected boxes for dragging

// access camera
try {
  const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
  video.srcObject = stream;
  await video.play();
} catch(e){
  alert('Camera access not available.');
  return;
}

// load ML model
model = await cocoSsd.load();
console.log('Model loaded');

// dragging state
let dragging = null;
let offset = {x:0, y:0};

// handle pointer drag
canvas.addEventListener('pointerdown', e => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  for(let i=boxes.length-1;i>=0;i--){
    const b = boxes[i];
    if(x>=b.screenX && x<=b.screenX+b.screenW && y>=b.screenY && y<=b.screenY+b.screenH){
      dragging = b;
      offset.x = x - b.screenX;
      offset.y = y - b.screenY;
      return;
    }
  }
});
canvas.addEventListener('pointermove', e => {
  if(dragging){
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    dragging.screenX = x - offset.x;
    dragging.screenY = y - offset.y;
  }
});
canvas.addEventListener('pointerup', e => { dragging = null; });
canvas.addEventListener('pointerleave', e => { dragging = null; });

// detection & drawing loop
async function detectLoop(){
  if(video.readyState === 4){
    const predictions = await model.detect(video);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // calculate video scaling inside container
    const container = document.getElementById('container');
    const videoRatio = video.videoWidth / video.videoHeight;
    const containerRatio = container.clientWidth / container.clientHeight;

    let scale = 1, offsetX = 0, offsetY = 0;
    if(videoRatio > containerRatio){
      scale = container.clientWidth / video.videoWidth;
      offsetY = (container.clientHeight - video.videoHeight*scale)/2;
    } else {
      scale = container.clientHeight / video.videoHeight;
      offsetX = (container.clientWidth - video.videoWidth*scale)/2;
    }

    boxes = predictions.map(p => {
      let [x,y,w,h] = p.bbox;
      return {
        x, y, w, h, class: p.class, score: p.score,
        screenX: x*scale + offsetX,
        screenY: y*scale + offsetY,
        screenW: w*scale,
        screenH: h*scale
      };
    });

    for(const b of boxes){
      let color = b.score<0.5 ? 'red' : b.score<0.8 ? 'yellow' : 'lime';
      ctx.strokeStyle=color;
      ctx.lineWidth=2;
      ctx.strokeRect(b.screenX, b.screenY, b.screenW, b.screenH);
      ctx.fillStyle=color;
      ctx.font='14px sans-serif';
      ctx.fillText(b.class + ' ' + Math.round(b.score*100)+'%', b.screenX +4, b.screenY +16);
    }
  }
  requestAnimationFrame(detectLoop);
}

// resize canvas to container
function resizeCanvas(){
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

detectLoop();
})();
</script>
</body>
</html>
